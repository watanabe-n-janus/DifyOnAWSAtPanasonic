"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.highlight = exports.success = exports.trace = exports.debug = exports.data = exports.print = exports.info = exports.warning = exports.error = exports.LogLevel = void 0;
exports.setLogLevel = setLogLevel;
exports.setCI = setCI;
exports.withCorkedLogging = withCorkedLogging;
exports.log = log;
exports.prefix = prefix;
const util = require("util");
const chalk = require("chalk");
/**
 * Available log levels in order of increasing verbosity.
 */
var LogLevel;
(function (LogLevel) {
    LogLevel["ERROR"] = "error";
    LogLevel["WARN"] = "warn";
    LogLevel["INFO"] = "info";
    LogLevel["DEBUG"] = "debug";
    LogLevel["TRACE"] = "trace";
})(LogLevel || (exports.LogLevel = LogLevel = {}));
const { stdout, stderr } = process;
// Corking mechanism
let CORK_COUNTER = 0;
const logBuffer = [];
// Style mappings
const styleMap = {
    [LogLevel.ERROR]: chalk.red,
    [LogLevel.WARN]: chalk.yellow,
    [LogLevel.INFO]: chalk.white,
    [LogLevel.DEBUG]: chalk.gray,
    [LogLevel.TRACE]: chalk.gray,
};
// Stream selection
let CI = false;
/**
 * Determines which output stream to use based on log level and configuration.
 * @param level - The log level to determine stream for
 * @param forceStdout - Whether to force stdout regardless of level
 * @returns The appropriate Writable stream
 */
const getStream = (level, forceStdout) => {
    // Special case - data() calls should always go to stdout
    if (forceStdout) {
        return stdout;
    }
    if (level === LogLevel.ERROR)
        return stderr;
    return CI ? stdout : stderr;
};
const levelPriority = {
    [LogLevel.ERROR]: 0,
    [LogLevel.WARN]: 1,
    [LogLevel.INFO]: 2,
    [LogLevel.DEBUG]: 3,
    [LogLevel.TRACE]: 4,
};
let currentLogLevel = LogLevel.INFO;
/**
 * Sets the current log level. Messages with a lower priority level will be filtered out.
 * @param level - The new log level to set
 */
function setLogLevel(level) {
    currentLogLevel = level;
}
/**
 * Sets whether the logger is running in CI mode.
 * In CI mode, all non-error output goes to stdout instead of stderr.
 * @param newCI - Whether CI mode should be enabled
 */
function setCI(newCI) {
    CI = newCI;
}
/**
 * Formats a date object into a timestamp string (HH:MM:SS).
 * @param d - Date object to format
 * @returns Formatted time string
 */
function formatTime(d) {
    const pad = (n) => n.toString().padStart(2, '0');
    return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
}
/**
 * Executes a block of code with corked logging. All log messages during execution
 * are buffered and only written after the block completes.
 * @param block - Async function to execute with corked logging
 * @returns Promise that resolves with the block's return value
 */
async function withCorkedLogging(block) {
    CORK_COUNTER++;
    try {
        return await block();
    }
    finally {
        CORK_COUNTER--;
        if (CORK_COUNTER === 0) {
            logBuffer.forEach(([stream, str]) => stream.write(str + '\n'));
            logBuffer.splice(0);
        }
    }
}
function log(levelOrEntry, fmt, ...args) {
    // Normalize input
    const entry = typeof levelOrEntry === 'string'
        ? { level: levelOrEntry, message: util.format(fmt, ...args) }
        : levelOrEntry;
    // Check if we should log this level
    if (levelPriority[entry.level] > levelPriority[currentLogLevel]) {
        return;
    }
    // Format the message
    let finalMessage = entry.message;
    // Add timestamp first if requested
    if (entry.timestamp) {
        finalMessage = `[${formatTime(new Date())}] ${finalMessage}`;
    }
    // Add prefix AFTER timestamp
    if (entry.prefix) {
        finalMessage = `${entry.prefix} ${finalMessage}`;
    }
    // Apply custom style if provided, otherwise use level-based style
    const style = entry.style || styleMap[entry.level];
    finalMessage = style(finalMessage);
    // Get appropriate stream - pass through forceStdout flag
    const stream = getStream(entry.level, entry.forceStdout);
    // Handle corking
    if (CORK_COUNTER > 0) {
        logBuffer.push([stream, finalMessage]);
        return;
    }
    // Write to stream
    stream.write(finalMessage + '\n');
}
// Convenience logging methods
const error = (fmt, ...args) => log(LogLevel.ERROR, fmt, ...args);
exports.error = error;
const warning = (fmt, ...args) => log(LogLevel.WARN, fmt, ...args);
exports.warning = warning;
const info = (fmt, ...args) => log(LogLevel.INFO, fmt, ...args);
exports.info = info;
const print = (fmt, ...args) => log(LogLevel.INFO, fmt, ...args);
exports.print = print;
const data = (fmt, ...args) => log({
    level: LogLevel.INFO,
    message: util.format(fmt, ...args),
    forceStdout: true,
});
exports.data = data;
const debug = (fmt, ...args) => log({
    level: LogLevel.DEBUG,
    message: util.format(fmt, ...args),
    timestamp: true,
});
exports.debug = debug;
const trace = (fmt, ...args) => log({
    level: LogLevel.TRACE,
    message: util.format(fmt, ...args),
    timestamp: true,
});
exports.trace = trace;
const success = (fmt, ...args) => log({
    level: LogLevel.INFO,
    message: util.format(fmt, ...args),
    style: chalk.green,
});
exports.success = success;
const highlight = (fmt, ...args) => log({
    level: LogLevel.INFO,
    message: util.format(fmt, ...args),
    style: chalk.bold,
});
exports.highlight = highlight;
/**
 * Creates a logging function that prepends a prefix to all messages.
 * @param prefixString - String to prepend to all messages
 * @param level - Log level to use (defaults to INFO)
 * @returns Logging function that accepts format string and arguments
 */
function prefix(prefixString, level = LogLevel.INFO) {
    return (fmt, ...args) => log({
        level,
        message: util.format(fmt, ...args),
        prefix: prefixString,
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9nZ2luZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImxvZ2dpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBMEVBLGtDQUVDO0FBT0Qsc0JBRUM7QUFrQkQsOENBV0M7QUFVRCxrQkF1Q0M7QUEwQ0Qsd0JBTUM7QUFsTkQsNkJBQTZCO0FBQzdCLCtCQUErQjtBQUUvQjs7R0FFRztBQUNILElBQVksUUFNWDtBQU5ELFdBQVksUUFBUTtJQUNsQiwyQkFBZSxDQUFBO0lBQ2YseUJBQWEsQ0FBQTtJQUNiLHlCQUFhLENBQUE7SUFDYiwyQkFBZSxDQUFBO0lBQ2YsMkJBQWUsQ0FBQTtBQUNqQixDQUFDLEVBTlcsUUFBUSx3QkFBUixRQUFRLFFBTW5CO0FBY0QsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsR0FBRyxPQUFPLENBQUM7QUFFbkMsb0JBQW9CO0FBQ3BCLElBQUksWUFBWSxHQUFHLENBQUMsQ0FBQztBQUNyQixNQUFNLFNBQVMsR0FBeUIsRUFBRSxDQUFDO0FBRTNDLGlCQUFpQjtBQUNqQixNQUFNLFFBQVEsR0FBOEM7SUFDMUQsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUUsS0FBSyxDQUFDLEdBQUc7SUFDM0IsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDLE1BQU07SUFDN0IsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDLEtBQUs7SUFDNUIsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUk7SUFDNUIsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUk7Q0FDN0IsQ0FBQztBQUVGLG1CQUFtQjtBQUNuQixJQUFJLEVBQUUsR0FBRyxLQUFLLENBQUM7QUFFZjs7Ozs7R0FLRztBQUNILE1BQU0sU0FBUyxHQUFHLENBQUMsS0FBZSxFQUFFLFdBQXFCLEVBQVksRUFBRTtJQUNyRSx5REFBeUQ7SUFDekQsSUFBSSxXQUFXLEVBQUUsQ0FBQztRQUNoQixPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBQ0QsSUFBSSxLQUFLLEtBQUssUUFBUSxDQUFDLEtBQUs7UUFBRSxPQUFPLE1BQU0sQ0FBQztJQUM1QyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDOUIsQ0FBQyxDQUFDO0FBRUYsTUFBTSxhQUFhLEdBQTZCO0lBQzlDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7SUFDbkIsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztJQUNsQixDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO0lBQ2xCLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7SUFDbkIsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQztDQUNwQixDQUFDO0FBRUYsSUFBSSxlQUFlLEdBQWEsUUFBUSxDQUFDLElBQUksQ0FBQztBQUU5Qzs7O0dBR0c7QUFDSCxTQUFnQixXQUFXLENBQUMsS0FBZTtJQUN6QyxlQUFlLEdBQUcsS0FBSyxDQUFDO0FBQzFCLENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBZ0IsS0FBSyxDQUFDLEtBQWM7SUFDbEMsRUFBRSxHQUFHLEtBQUssQ0FBQztBQUNiLENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBUyxVQUFVLENBQUMsQ0FBTztJQUN6QixNQUFNLEdBQUcsR0FBRyxDQUFDLENBQVMsRUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDakUsT0FBTyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLFVBQVUsRUFBRSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLENBQUM7QUFDOUUsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0ksS0FBSyxVQUFVLGlCQUFpQixDQUFJLEtBQXVCO0lBQ2hFLFlBQVksRUFBRSxDQUFDO0lBQ2YsSUFBSSxDQUFDO1FBQ0gsT0FBTyxNQUFNLEtBQUssRUFBRSxDQUFDO0lBQ3ZCLENBQUM7WUFBUyxDQUFDO1FBQ1QsWUFBWSxFQUFFLENBQUM7UUFDZixJQUFJLFlBQVksS0FBSyxDQUFDLEVBQUUsQ0FBQztZQUN2QixTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDL0QsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0QixDQUFDO0lBQ0gsQ0FBQztBQUNILENBQUM7QUFVRCxTQUFnQixHQUFHLENBQUMsWUFBaUMsRUFBRSxHQUFZLEVBQUUsR0FBRyxJQUFlO0lBQ3JGLGtCQUFrQjtJQUNsQixNQUFNLEtBQUssR0FBYSxPQUFPLFlBQVksS0FBSyxRQUFRO1FBQ3RELENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxZQUF3QixFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFO1FBQzFFLENBQUMsQ0FBQyxZQUFZLENBQUM7SUFFakIsb0NBQW9DO0lBQ3BDLElBQUksYUFBYSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxhQUFhLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQztRQUNoRSxPQUFPO0lBQ1QsQ0FBQztJQUVELHFCQUFxQjtJQUNyQixJQUFJLFlBQVksR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDO0lBRWpDLG1DQUFtQztJQUNuQyxJQUFJLEtBQUssQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNwQixZQUFZLEdBQUcsSUFBSSxVQUFVLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQyxLQUFLLFlBQVksRUFBRSxDQUFDO0lBQy9ELENBQUM7SUFFRCw2QkFBNkI7SUFDN0IsSUFBSSxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDakIsWUFBWSxHQUFHLEdBQUcsS0FBSyxDQUFDLE1BQU0sSUFBSSxZQUFZLEVBQUUsQ0FBQztJQUNuRCxDQUFDO0lBRUQsa0VBQWtFO0lBQ2xFLE1BQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNuRCxZQUFZLEdBQUcsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBRW5DLHlEQUF5RDtJQUN6RCxNQUFNLE1BQU0sR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7SUFFekQsaUJBQWlCO0lBQ2pCLElBQUksWUFBWSxHQUFHLENBQUMsRUFBRSxDQUFDO1FBQ3JCLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQztRQUN2QyxPQUFPO0lBQ1QsQ0FBQztJQUVELGtCQUFrQjtJQUNsQixNQUFNLENBQUMsS0FBSyxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsQ0FBQztBQUNwQyxDQUFDO0FBRUQsOEJBQThCO0FBQ3ZCLE1BQU0sS0FBSyxHQUFHLENBQUMsR0FBVyxFQUFFLEdBQUcsSUFBZSxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQztBQUEvRSxRQUFBLEtBQUssU0FBMEU7QUFDckYsTUFBTSxPQUFPLEdBQUcsQ0FBQyxHQUFXLEVBQUUsR0FBRyxJQUFlLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDO0FBQWhGLFFBQUEsT0FBTyxXQUF5RTtBQUN0RixNQUFNLElBQUksR0FBRyxDQUFDLEdBQVcsRUFBRSxHQUFHLElBQWUsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUM7QUFBN0UsUUFBQSxJQUFJLFFBQXlFO0FBQ25GLE1BQU0sS0FBSyxHQUFHLENBQUMsR0FBVyxFQUFFLEdBQUcsSUFBZSxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQztBQUE5RSxRQUFBLEtBQUssU0FBeUU7QUFDcEYsTUFBTSxJQUFJLEdBQUcsQ0FBQyxHQUFXLEVBQUUsR0FBRyxJQUFlLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQztJQUMzRCxLQUFLLEVBQUUsUUFBUSxDQUFDLElBQUk7SUFDcEIsT0FBTyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDO0lBQ2xDLFdBQVcsRUFBRSxJQUFJO0NBQ2xCLENBQUMsQ0FBQztBQUpVLFFBQUEsSUFBSSxRQUlkO0FBQ0ksTUFBTSxLQUFLLEdBQUcsQ0FBQyxHQUFXLEVBQUUsR0FBRyxJQUFlLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQztJQUM1RCxLQUFLLEVBQUUsUUFBUSxDQUFDLEtBQUs7SUFDckIsT0FBTyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDO0lBQ2xDLFNBQVMsRUFBRSxJQUFJO0NBQ2hCLENBQUMsQ0FBQztBQUpVLFFBQUEsS0FBSyxTQUlmO0FBRUksTUFBTSxLQUFLLEdBQUcsQ0FBQyxHQUFXLEVBQUUsR0FBRyxJQUFlLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQztJQUM1RCxLQUFLLEVBQUUsUUFBUSxDQUFDLEtBQUs7SUFDckIsT0FBTyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDO0lBQ2xDLFNBQVMsRUFBRSxJQUFJO0NBQ2hCLENBQUMsQ0FBQztBQUpVLFFBQUEsS0FBSyxTQUlmO0FBRUksTUFBTSxPQUFPLEdBQUcsQ0FBQyxHQUFXLEVBQUUsR0FBRyxJQUFlLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQztJQUM5RCxLQUFLLEVBQUUsUUFBUSxDQUFDLElBQUk7SUFDcEIsT0FBTyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDO0lBQ2xDLEtBQUssRUFBRSxLQUFLLENBQUMsS0FBSztDQUNuQixDQUFDLENBQUM7QUFKVSxRQUFBLE9BQU8sV0FJakI7QUFFSSxNQUFNLFNBQVMsR0FBRyxDQUFDLEdBQVcsRUFBRSxHQUFHLElBQWUsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDO0lBQ2hFLEtBQUssRUFBRSxRQUFRLENBQUMsSUFBSTtJQUNwQixPQUFPLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUM7SUFDbEMsS0FBSyxFQUFFLEtBQUssQ0FBQyxJQUFJO0NBQ2xCLENBQUMsQ0FBQztBQUpVLFFBQUEsU0FBUyxhQUluQjtBQUVIOzs7OztHQUtHO0FBQ0gsU0FBZ0IsTUFBTSxDQUFDLFlBQW9CLEVBQUUsUUFBa0IsUUFBUSxDQUFDLElBQUk7SUFDMUUsT0FBTyxDQUFDLEdBQVcsRUFBRSxHQUFHLElBQWUsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDO1FBQzlDLEtBQUs7UUFDTCxPQUFPLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUM7UUFDbEMsTUFBTSxFQUFFLFlBQVk7S0FDckIsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFdyaXRhYmxlIH0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAndXRpbCc7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tICdjaGFsayc7XG5cbi8qKlxuICogQXZhaWxhYmxlIGxvZyBsZXZlbHMgaW4gb3JkZXIgb2YgaW5jcmVhc2luZyB2ZXJib3NpdHkuXG4gKi9cbmV4cG9ydCBlbnVtIExvZ0xldmVsIHtcbiAgRVJST1IgPSAnZXJyb3InLFxuICBXQVJOID0gJ3dhcm4nLFxuICBJTkZPID0gJ2luZm8nLFxuICBERUJVRyA9ICdkZWJ1ZycsXG4gIFRSQUNFID0gJ3RyYWNlJyxcbn1cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIGEgbG9nIGVudHJ5LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIExvZ0VudHJ5IHtcbiAgbGV2ZWw6IExvZ0xldmVsO1xuICBtZXNzYWdlOiBzdHJpbmc7XG4gIHRpbWVzdGFtcD86IGJvb2xlYW47XG4gIHByZWZpeD86IHN0cmluZztcbiAgc3R5bGU/OiAoKHN0cjogc3RyaW5nKSA9PiBzdHJpbmcpO1xuICBmb3JjZVN0ZG91dD86IGJvb2xlYW47XG59XG5cbmNvbnN0IHsgc3Rkb3V0LCBzdGRlcnIgfSA9IHByb2Nlc3M7XG5cbi8vIENvcmtpbmcgbWVjaGFuaXNtXG5sZXQgQ09SS19DT1VOVEVSID0gMDtcbmNvbnN0IGxvZ0J1ZmZlcjogW1dyaXRhYmxlLCBzdHJpbmddW10gPSBbXTtcblxuLy8gU3R5bGUgbWFwcGluZ3NcbmNvbnN0IHN0eWxlTWFwOiBSZWNvcmQ8TG9nTGV2ZWwsIChzdHI6IHN0cmluZykgPT4gc3RyaW5nPiA9IHtcbiAgW0xvZ0xldmVsLkVSUk9SXTogY2hhbGsucmVkLFxuICBbTG9nTGV2ZWwuV0FSTl06IGNoYWxrLnllbGxvdyxcbiAgW0xvZ0xldmVsLklORk9dOiBjaGFsay53aGl0ZSxcbiAgW0xvZ0xldmVsLkRFQlVHXTogY2hhbGsuZ3JheSxcbiAgW0xvZ0xldmVsLlRSQUNFXTogY2hhbGsuZ3JheSxcbn07XG5cbi8vIFN0cmVhbSBzZWxlY3Rpb25cbmxldCBDSSA9IGZhbHNlO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hpY2ggb3V0cHV0IHN0cmVhbSB0byB1c2UgYmFzZWQgb24gbG9nIGxldmVsIGFuZCBjb25maWd1cmF0aW9uLlxuICogQHBhcmFtIGxldmVsIC0gVGhlIGxvZyBsZXZlbCB0byBkZXRlcm1pbmUgc3RyZWFtIGZvclxuICogQHBhcmFtIGZvcmNlU3Rkb3V0IC0gV2hldGhlciB0byBmb3JjZSBzdGRvdXQgcmVnYXJkbGVzcyBvZiBsZXZlbFxuICogQHJldHVybnMgVGhlIGFwcHJvcHJpYXRlIFdyaXRhYmxlIHN0cmVhbVxuICovXG5jb25zdCBnZXRTdHJlYW0gPSAobGV2ZWw6IExvZ0xldmVsLCBmb3JjZVN0ZG91dD86IGJvb2xlYW4pOiBXcml0YWJsZSA9PiB7XG4gIC8vIFNwZWNpYWwgY2FzZSAtIGRhdGEoKSBjYWxscyBzaG91bGQgYWx3YXlzIGdvIHRvIHN0ZG91dFxuICBpZiAoZm9yY2VTdGRvdXQpIHtcbiAgICByZXR1cm4gc3Rkb3V0O1xuICB9XG4gIGlmIChsZXZlbCA9PT0gTG9nTGV2ZWwuRVJST1IpIHJldHVybiBzdGRlcnI7XG4gIHJldHVybiBDSSA/IHN0ZG91dCA6IHN0ZGVycjtcbn07XG5cbmNvbnN0IGxldmVsUHJpb3JpdHk6IFJlY29yZDxMb2dMZXZlbCwgbnVtYmVyPiA9IHtcbiAgW0xvZ0xldmVsLkVSUk9SXTogMCxcbiAgW0xvZ0xldmVsLldBUk5dOiAxLFxuICBbTG9nTGV2ZWwuSU5GT106IDIsXG4gIFtMb2dMZXZlbC5ERUJVR106IDMsXG4gIFtMb2dMZXZlbC5UUkFDRV06IDQsXG59O1xuXG5sZXQgY3VycmVudExvZ0xldmVsOiBMb2dMZXZlbCA9IExvZ0xldmVsLklORk87XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCBsb2cgbGV2ZWwuIE1lc3NhZ2VzIHdpdGggYSBsb3dlciBwcmlvcml0eSBsZXZlbCB3aWxsIGJlIGZpbHRlcmVkIG91dC5cbiAqIEBwYXJhbSBsZXZlbCAtIFRoZSBuZXcgbG9nIGxldmVsIHRvIHNldFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWw6IExvZ0xldmVsKSB7XG4gIGN1cnJlbnRMb2dMZXZlbCA9IGxldmVsO1xufVxuXG4vKipcbiAqIFNldHMgd2hldGhlciB0aGUgbG9nZ2VyIGlzIHJ1bm5pbmcgaW4gQ0kgbW9kZS5cbiAqIEluIENJIG1vZGUsIGFsbCBub24tZXJyb3Igb3V0cHV0IGdvZXMgdG8gc3Rkb3V0IGluc3RlYWQgb2Ygc3RkZXJyLlxuICogQHBhcmFtIG5ld0NJIC0gV2hldGhlciBDSSBtb2RlIHNob3VsZCBiZSBlbmFibGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRDSShuZXdDSTogYm9vbGVhbikge1xuICBDSSA9IG5ld0NJO1xufVxuXG4vKipcbiAqIEZvcm1hdHMgYSBkYXRlIG9iamVjdCBpbnRvIGEgdGltZXN0YW1wIHN0cmluZyAoSEg6TU06U1MpLlxuICogQHBhcmFtIGQgLSBEYXRlIG9iamVjdCB0byBmb3JtYXRcbiAqIEByZXR1cm5zIEZvcm1hdHRlZCB0aW1lIHN0cmluZ1xuICovXG5mdW5jdGlvbiBmb3JtYXRUaW1lKGQ6IERhdGUpOiBzdHJpbmcge1xuICBjb25zdCBwYWQgPSAobjogbnVtYmVyKTogc3RyaW5nID0+IG4udG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpO1xuICByZXR1cm4gYCR7cGFkKGQuZ2V0SG91cnMoKSl9OiR7cGFkKGQuZ2V0TWludXRlcygpKX06JHtwYWQoZC5nZXRTZWNvbmRzKCkpfWA7XG59XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBibG9jayBvZiBjb2RlIHdpdGggY29ya2VkIGxvZ2dpbmcuIEFsbCBsb2cgbWVzc2FnZXMgZHVyaW5nIGV4ZWN1dGlvblxuICogYXJlIGJ1ZmZlcmVkIGFuZCBvbmx5IHdyaXR0ZW4gYWZ0ZXIgdGhlIGJsb2NrIGNvbXBsZXRlcy5cbiAqIEBwYXJhbSBibG9jayAtIEFzeW5jIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2l0aCBjb3JrZWQgbG9nZ2luZ1xuICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGJsb2NrJ3MgcmV0dXJuIHZhbHVlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3aXRoQ29ya2VkTG9nZ2luZzxUPihibG9jazogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICBDT1JLX0NPVU5URVIrKztcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgYmxvY2soKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBDT1JLX0NPVU5URVItLTtcbiAgICBpZiAoQ09SS19DT1VOVEVSID09PSAwKSB7XG4gICAgICBsb2dCdWZmZXIuZm9yRWFjaCgoW3N0cmVhbSwgc3RyXSkgPT4gc3RyZWFtLndyaXRlKHN0ciArICdcXG4nKSk7XG4gICAgICBsb2dCdWZmZXIuc3BsaWNlKDApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvcmUgbG9nZ2luZyBmdW5jdGlvbiB0aGF0IGhhbmRsZXMgYWxsIGxvZyBvdXRwdXQuXG4gKiBAcGFyYW0gZW50cnkgLSBMb2dFbnRyeSBvYmplY3Qgb3IgbG9nIGxldmVsXG4gKiBAcGFyYW0gZm10IC0gRm9ybWF0IHN0cmluZyAod2hlbiB1c2luZyB3aXRoIGxvZyBsZXZlbClcbiAqIEBwYXJhbSBhcmdzIC0gRm9ybWF0IGFyZ3VtZW50cyAod2hlbiB1c2luZyB3aXRoIGxvZyBsZXZlbClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvZyhlbnRyeTogTG9nRW50cnkpOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIGxvZyhsZXZlbDogTG9nTGV2ZWwsIGZtdDogc3RyaW5nLCAuLi5hcmdzOiB1bmtub3duW10pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIGxvZyhsZXZlbE9yRW50cnk6IExvZ0xldmVsIHwgTG9nRW50cnksIGZtdD86IHN0cmluZywgLi4uYXJnczogdW5rbm93bltdKTogdm9pZCB7XG4gIC8vIE5vcm1hbGl6ZSBpbnB1dFxuICBjb25zdCBlbnRyeTogTG9nRW50cnkgPSB0eXBlb2YgbGV2ZWxPckVudHJ5ID09PSAnc3RyaW5nJ1xuICAgID8geyBsZXZlbDogbGV2ZWxPckVudHJ5IGFzIExvZ0xldmVsLCBtZXNzYWdlOiB1dGlsLmZvcm1hdChmbXQhLCAuLi5hcmdzKSB9XG4gICAgOiBsZXZlbE9yRW50cnk7XG5cbiAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIGxvZyB0aGlzIGxldmVsXG4gIGlmIChsZXZlbFByaW9yaXR5W2VudHJ5LmxldmVsXSA+IGxldmVsUHJpb3JpdHlbY3VycmVudExvZ0xldmVsXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcm1hdCB0aGUgbWVzc2FnZVxuICBsZXQgZmluYWxNZXNzYWdlID0gZW50cnkubWVzc2FnZTtcblxuICAvLyBBZGQgdGltZXN0YW1wIGZpcnN0IGlmIHJlcXVlc3RlZFxuICBpZiAoZW50cnkudGltZXN0YW1wKSB7XG4gICAgZmluYWxNZXNzYWdlID0gYFske2Zvcm1hdFRpbWUobmV3IERhdGUoKSl9XSAke2ZpbmFsTWVzc2FnZX1gO1xuICB9XG5cbiAgLy8gQWRkIHByZWZpeCBBRlRFUiB0aW1lc3RhbXBcbiAgaWYgKGVudHJ5LnByZWZpeCkge1xuICAgIGZpbmFsTWVzc2FnZSA9IGAke2VudHJ5LnByZWZpeH0gJHtmaW5hbE1lc3NhZ2V9YDtcbiAgfVxuXG4gIC8vIEFwcGx5IGN1c3RvbSBzdHlsZSBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIHVzZSBsZXZlbC1iYXNlZCBzdHlsZVxuICBjb25zdCBzdHlsZSA9IGVudHJ5LnN0eWxlIHx8IHN0eWxlTWFwW2VudHJ5LmxldmVsXTtcbiAgZmluYWxNZXNzYWdlID0gc3R5bGUoZmluYWxNZXNzYWdlKTtcblxuICAvLyBHZXQgYXBwcm9wcmlhdGUgc3RyZWFtIC0gcGFzcyB0aHJvdWdoIGZvcmNlU3Rkb3V0IGZsYWdcbiAgY29uc3Qgc3RyZWFtID0gZ2V0U3RyZWFtKGVudHJ5LmxldmVsLCBlbnRyeS5mb3JjZVN0ZG91dCk7XG5cbiAgLy8gSGFuZGxlIGNvcmtpbmdcbiAgaWYgKENPUktfQ09VTlRFUiA+IDApIHtcbiAgICBsb2dCdWZmZXIucHVzaChbc3RyZWFtLCBmaW5hbE1lc3NhZ2VdKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBXcml0ZSB0byBzdHJlYW1cbiAgc3RyZWFtLndyaXRlKGZpbmFsTWVzc2FnZSArICdcXG4nKTtcbn1cblxuLy8gQ29udmVuaWVuY2UgbG9nZ2luZyBtZXRob2RzXG5leHBvcnQgY29uc3QgZXJyb3IgPSAoZm10OiBzdHJpbmcsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gbG9nKExvZ0xldmVsLkVSUk9SLCBmbXQsIC4uLmFyZ3MpO1xuZXhwb3J0IGNvbnN0IHdhcm5pbmcgPSAoZm10OiBzdHJpbmcsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gbG9nKExvZ0xldmVsLldBUk4sIGZtdCwgLi4uYXJncyk7XG5leHBvcnQgY29uc3QgaW5mbyA9IChmbXQ6IHN0cmluZywgLi4uYXJnczogdW5rbm93bltdKSA9PiBsb2coTG9nTGV2ZWwuSU5GTywgZm10LCAuLi5hcmdzKTtcbmV4cG9ydCBjb25zdCBwcmludCA9IChmbXQ6IHN0cmluZywgLi4uYXJnczogdW5rbm93bltdKSA9PiBsb2coTG9nTGV2ZWwuSU5GTywgZm10LCAuLi5hcmdzKTtcbmV4cG9ydCBjb25zdCBkYXRhID0gKGZtdDogc3RyaW5nLCAuLi5hcmdzOiB1bmtub3duW10pID0+IGxvZyh7XG4gIGxldmVsOiBMb2dMZXZlbC5JTkZPLFxuICBtZXNzYWdlOiB1dGlsLmZvcm1hdChmbXQsIC4uLmFyZ3MpLFxuICBmb3JjZVN0ZG91dDogdHJ1ZSxcbn0pO1xuZXhwb3J0IGNvbnN0IGRlYnVnID0gKGZtdDogc3RyaW5nLCAuLi5hcmdzOiB1bmtub3duW10pID0+IGxvZyh7XG4gIGxldmVsOiBMb2dMZXZlbC5ERUJVRyxcbiAgbWVzc2FnZTogdXRpbC5mb3JtYXQoZm10LCAuLi5hcmdzKSxcbiAgdGltZXN0YW1wOiB0cnVlLFxufSk7XG5cbmV4cG9ydCBjb25zdCB0cmFjZSA9IChmbXQ6IHN0cmluZywgLi4uYXJnczogdW5rbm93bltdKSA9PiBsb2coe1xuICBsZXZlbDogTG9nTGV2ZWwuVFJBQ0UsXG4gIG1lc3NhZ2U6IHV0aWwuZm9ybWF0KGZtdCwgLi4uYXJncyksXG4gIHRpbWVzdGFtcDogdHJ1ZSxcbn0pO1xuXG5leHBvcnQgY29uc3Qgc3VjY2VzcyA9IChmbXQ6IHN0cmluZywgLi4uYXJnczogdW5rbm93bltdKSA9PiBsb2coe1xuICBsZXZlbDogTG9nTGV2ZWwuSU5GTyxcbiAgbWVzc2FnZTogdXRpbC5mb3JtYXQoZm10LCAuLi5hcmdzKSxcbiAgc3R5bGU6IGNoYWxrLmdyZWVuLFxufSk7XG5cbmV4cG9ydCBjb25zdCBoaWdobGlnaHQgPSAoZm10OiBzdHJpbmcsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gbG9nKHtcbiAgbGV2ZWw6IExvZ0xldmVsLklORk8sXG4gIG1lc3NhZ2U6IHV0aWwuZm9ybWF0KGZtdCwgLi4uYXJncyksXG4gIHN0eWxlOiBjaGFsay5ib2xkLFxufSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGxvZ2dpbmcgZnVuY3Rpb24gdGhhdCBwcmVwZW5kcyBhIHByZWZpeCB0byBhbGwgbWVzc2FnZXMuXG4gKiBAcGFyYW0gcHJlZml4U3RyaW5nIC0gU3RyaW5nIHRvIHByZXBlbmQgdG8gYWxsIG1lc3NhZ2VzXG4gKiBAcGFyYW0gbGV2ZWwgLSBMb2cgbGV2ZWwgdG8gdXNlIChkZWZhdWx0cyB0byBJTkZPKVxuICogQHJldHVybnMgTG9nZ2luZyBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgZm9ybWF0IHN0cmluZyBhbmQgYXJndW1lbnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVmaXgocHJlZml4U3RyaW5nOiBzdHJpbmcsIGxldmVsOiBMb2dMZXZlbCA9IExvZ0xldmVsLklORk8pOiAoZm10OiBzdHJpbmcsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZCB7XG4gIHJldHVybiAoZm10OiBzdHJpbmcsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gbG9nKHtcbiAgICBsZXZlbCxcbiAgICBtZXNzYWdlOiB1dGlsLmZvcm1hdChmbXQsIC4uLmFyZ3MpLFxuICAgIHByZWZpeDogcHJlZml4U3RyaW5nLFxuICB9KTtcbn1cbiJdfQ==